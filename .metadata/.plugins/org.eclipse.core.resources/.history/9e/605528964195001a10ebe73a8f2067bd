/*
 * generated by Xtext 2.20.0
 */
package useCase.xtext.useCaseDsl.scoping;

import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;

import com.google.common.base.Function;
import com.google.inject.Inject;

import useCase.xtext.useCaseDsl.useCaseDsl.Extension;
import useCase.xtext.useCaseDsl.useCaseDsl.ExtensionStep;
import useCase.xtext.useCaseDsl.useCaseDsl.RepeatingStep;
import useCase.xtext.useCaseDsl.useCaseDsl.Step;
import useCase.xtext.useCaseDsl.useCaseDsl.UseCase;
import useCase.xtext.useCaseDsl.useCaseDsl.UseCaseDslPackage;
import useCase.xtext.useCaseDsl.useCaseDsl.UseCaseStep;

import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;



/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class UseCaseDslScopeProvider extends AbstractUseCaseDslScopeProvider {

	/*@Override
	public IScope getScope (EObject context, EReference reference) {
		
		if (context instanceof RepeatingStep && 
				reference == UseCaseDslPackage.Literals.EXTENSION__START_FROM) {
			
			EObject repref = EcoreUtil2.getRootContainer(context);
	        List<RepeatingStep> candidates = EcoreUtil2.getAllContentsOfType(repref, RepeatingStep.class);
	        // Create IEObjectDescriptions and puts them into an IScope instance
	        candidates.add((RepeatingStep) context);
	        return Scopes.scopeFor(candidates);
	    }
	    return super.getScope(context, reference);
			
	}*/
	@Inject IQualifiedNameProvider iq;
	@Override
	public IScope getScope(EObject context, EReference reference) {
		//Scoping for parent in loops
		if(context instanceof UseCaseStep && context.eContainer() instanceof RepeatingStep 
			&& reference == UseCaseDslPackage.Literals.USE_CASE_STEP__PARENT) {
	
			List<RepeatingStep> candidates = new LinkedList<RepeatingStep>();
			candidates.add((RepeatingStep) context.eContainer());
			

	        return Scopes.scopeFor(candidates, new Function<RepeatingStep, QualifiedName>() {
				@Override
				public QualifiedName apply(RepeatingStep from) {
					String names[] = new String[iq.getFullyQualifiedName(context.eContainer()).getSegmentCount() -1];
					for(int i = 0; i < iq.getFullyQualifiedName(context.eContainer()).getSegmentCount() - 1; i++) {
						names[i] = iq.getFullyQualifiedName(context.eContainer()).getSegment(i + 1);
					}
					
				//	names[iq.getFullyQualifiedName(context.eContainer()).getSegmentCount() - 1] = from.getName();
					return QualifiedName.create(names);
				}
			}, IScope.NULLSCOPE);
		}
		
		//Scoping for extensions
		if(context instanceof Extension && reference == UseCaseDslPackage.Literals.EXTENSION__START_FROM) {
			
			
			UseCase parent = (UseCase) context.eContainer();
			List<Step> candidates = EcoreUtil2.getAllContentsOfType(parent, Step.class);
//			candidates.addAll(parent.getSteps());
//			List<Extension> ext = parent.getAlternativeflows();
//			Iterator<Extension> it = ext.iterator();
//			while(it.hasNext()) {
//				Extension a = it.next();
//				candidates.addAll(a.getSteps());
//			}
//			
			return Scopes.scopeFor(candidates, new Function<Step, QualifiedName>() {
				@Override
				public QualifiedName apply(Step from) {
					List<INode> nodes = NodeModelUtils.findNodesForFeature(context,
							UseCaseDslPackage.Literals.EXTENSION__START_FROM);
					INode actual = NodeModelUtils.findActualNodeFor(context);
					Iterator<INode> it = nodes.iterator();
				//	List<String> intermediate = new LinkedList<String>();
					String names[] = null;
					while(it.hasNext()) {
						INode a = it.next();
						String text = NodeModelUtils.getTokenText(a);
						System.out.println("AQUI :" + text);
						if(text != null) {
							String fullname = parent.getName() + "." + text;
							names = fullname.split(".");
							System.out.println("NAME :" + Arrays.toString(names));

//							for (int i = 0, j = 0; i < text.length(); i++) {
//								if(text.charAt(i) == '.') {
//									intermediate.add(text.substring(j, i));
//									j = i + 1;
//								}
//								if(i == text.length() - 1) {
//									intermediate.add(text.substring(i, i + 1));
//								}
//								
//							}

						}
					}
			//		String names[] = new String[intermediate.size()];
			//		Iterator<String> itinter = intermediate.iterator();
//					for(int i = 0; itinter.hasNext(); i++) {
//						names[i] = itinter.next();
//					}
					return QualifiedName.create(names);
//					
//					String names[] = new String[QualifiedName.create(((Extension)context).getStartFrom().getName()).getSegmentCount()];
//					for(int i = 0; i < iq.getFullyQualifiedName(((Extension)context).getStartFrom()).getSegmentCount(); i++) {
//						names[i] = iq.getFullyQualifiedName(((Extension)context).getStartFrom()).getSegment(i + 1);
//					}
//					
//				//	names[iq.getFullyQualifiedName(context.eContainer()).getSegmentCount() - 1] = from.getName();
//					return QualifiedName.create(((Extension)context).getStartFrom().getName());
				}
			}, IScope.NULLSCOPE);
			
			
			
//			char[] alphabet = "abcdefghijklmnopqrstuvwxyz".toCharArray();
//				for(char c	:	alphabet) {
//					if(((Extension)context).getStartFrom().getName().indexOf(c) >= 0) {
//							
//						UseCase parent = (UseCase) context.eContainer();
//						List<UseCaseStep> candidates = parent.getSteps();
//				        return Scopes.scopeFor(candidates, new Function<UseCaseStep, QualifiedName>() {
//							public QualifiedName apply(UseCaseStep from) {
//								String names[] = new String[iq.getFullyQualifiedName(((Extension) context).getStartFrom()).getSegmentCount() -1];
//								for(int i = 0; i < iq.getFullyQualifiedName(((Extension) context).getStartFrom()).getSegmentCount() - 1; i++) {
//									names[i] = iq.getFullyQualifiedName(((Extension) context).getStartFrom()).getSegment(i + 1);
//								}
//								
//							//	names[iq.getFullyQualifiedName(context.eContainer()).getSegmentCount() - 1] = from.getName();
//								return QualifiedName.create(names);
//							}
//						}, IScope.NULLSCOPE);
//					
//					}else {
//						UseCase parent = (UseCase) context.eContainer();
//						EList<Extension> alt = parent.getAlternativeflows();
//						Iterator<Extension> it = alt.iterator();
//						List<ExtensionStep> candidates = new LinkedList<ExtensionStep> ();
//						while(it.hasNext()) {
//							Extension a = it.next();	
//							candidates.addAll(a.getSteps());
//						}
//
//				        return Scopes.scopeFor(candidates, new Function<ExtensionStep, QualifiedName>() {
//							public QualifiedName apply(ExtensionStep from) {
//								String names[] = new String[iq.getFullyQualifiedName(((Extension) context).getStartFrom()).getSegmentCount() -1];
//								for(int i = 0; i < iq.getFullyQualifiedName(((Extension) context).getStartFrom()).getSegmentCount() - 1; i++) {
//									names[i] = iq.getFullyQualifiedName(((Extension) context).getStartFrom()).getSegment(i + 1);
//								}
//								
//							//	names[iq.getFullyQualifiedName(context.eContainer()).getSegmentCount() - 1] = from.getName();
//								return QualifiedName.create(names);
//							}
//						}, IScope.NULLSCOPE);
//					}
//				
//				}
		}
	    return super.getScope(context, reference);
	}
}

